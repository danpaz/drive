{"version":3,"sources":["Banner.js","RouteDetails.js","SearchDetails.js","App.js","serviceWorker.js","index.js"],"names":["Banner","_this$props","this","props","routeResult","distanceAlongGeometry","currentRouteStepIndex","currentStep","legs","steps","distanceToManeuver","distance","bannerInstruction","bannerInstructions","i","length","react_default","a","createElement","className","primary","text","secondary","Component","RouteDetails","sec","m","onClickStartNavigation","onClickStartSimulation","onClickCancelNavigation","isNavigating","time","duration","value","Math","round","unit","onClick","searchResult","properties","address","geoViewport","require","baseClient","mbxClient","accessToken","process","directionsService","mbxDirections","simulateLocation","routeGeometry","routeDistance","cb","distanceIncrement","step","setInterval","point","along","units","coords","longitude","geometry","coordinates","latitude","timestamp","Date","now","updateLocation","requestGeolocation","Promise","resolve","reject","navigator","geolocation","getCurrentPosition","App","state","viewport","width","window","innerWidth","height","innerHeight","zoom","maxZoom","transitionDuration","geolocationWatcher","currentPosition","lastupdated","currentPositionLayer","searchResultLayer","routeResultLayer","simulationIntervalId","mapRef","React","createRef","handleViewportChange","_this","setState","Object","objectSpread","handleSearchResult","event","result","GeoJsonLayer","id","data","getFillColor","getLineColor","getRadius","pointRadiusMinPixels","getLineWidth","lineWidthMinPixels","stroked","filled","handleSearchClear","handlePositionChange","type","handleGetDirections","then","p","start","end","options","profile","geometries","overview","waypoints","getDirections","send","response","body","routes","requestDirections","center","r","bounds","reduce","coord","extend","mapboxgl","LngLatBounds","getWest","getSouth","getEast","getNorth","catch","err","console","error","handleNewPositionSuccess","snappedPosition","nextStep","snappedPositionToCurrentStep","nearestPointOnLine","turf","snappedPositionToNextStep","dist","location","handleNewPositionError","handleStartNavigation","onSuccess","onError","watchPosition","enableHighAccuracy","maximumAge","handleStartSimulation","_this$state$routeResu","handleCancelNavigation","clearInterval","_this2","BottomBanner","_this$state","SearchDetails","src_RouteDetails","Fragment","src_Banner","esm","assign","mapStyle","ref","onViewportChange","dist_default","onResult","onClear","mapboxApiAccessToken","proximity","position","placeholder","dist_esm","layers","Boolean","hostname","match","ReactDOM","render","src_App","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.43bcd733.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './banner.css';\n\nclass Banner extends Component {\n  render() {\n    const { routeResult, distanceAlongGeometry, currentRouteStepIndex } = this.props;\n    const currentStep = routeResult.legs[0].steps[currentRouteStepIndex]; // TODO how to progress to next step\n\n    let distanceToManeuver = currentStep.distance - distanceAlongGeometry;\n\n    let bannerInstruction = currentStep.bannerInstructions[0];\n    for (let i = 0; i < currentStep.bannerInstructions.length; i++) {\n      if (currentStep.bannerInstructions[i].distanceAlongGeometry > distanceToManeuver) {\n        bannerInstruction = currentStep.bannerInstructions[i];\n      }\n    }\n\n    return (\n      <div className='banner'>\n        <div className='primary'>\n          {bannerInstruction.primary.text}\n        </div>\n        <div className='secondary'>\n          {bannerInstruction.secondary && bannerInstruction.secondary.text}\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default Banner;\n","import React, { Component } from 'react';\n\nfunction formatTime(sec) {\n  const value = Math.round(sec / 60);\n  const unit = 'min';\n\n  return { value, unit }\n}\n\n\nfunction formatDistance(m) {\n  const value = Math.round(m / 1000);\n  const unit = 'km';\n\n  return { value, unit }\n}\n\nclass RouteDetails extends Component {\n  render() {\n    const { routeResult, onClickStartNavigation, onClickStartSimulation, onClickCancelNavigation, isNavigating } = this.props;\n\n    const time = formatTime(routeResult.duration);\n    const distance = formatDistance(routeResult.distance);\n\n    return (\n      <div>\n        { isNavigating ? (\n          <button onClick={onClickCancelNavigation}>Cancel</button>\n        ) : (\n          <div>\n            <div>\n              {time.value} {time.unit} ({distance.value} {distance.unit})\n            </div>\n            <div>\n              <button onClick={onClickStartNavigation}>Start</button>\n              <button onClick={onClickStartSimulation}>Simulate</button>\n            </div>\n          </div>\n        )}\n      </div>\n    )\n  }\n}\n\nexport default RouteDetails;\n","import React, { Component } from 'react';\n\nclass RouteDetails extends Component {\n  render() {\n    const { searchResult, onClick } = this.props;\n    return (\n      <div>\n        <div>{searchResult.text}</div>\n        <div>{searchResult.properties.address}</div>\n        <button onClick={onClick}>Directions</button>\n      </div>\n    )\n  }\n}\n\nexport default RouteDetails;\n","import React, { Component } from 'react';\nimport Banner from './Banner';\nimport RouteDetails from './RouteDetails';\nimport SearchDetails from './SearchDetails';\nimport MapGL from 'react-map-gl';\nimport Geocoder from 'react-map-gl-geocoder';\nimport DeckGL, { GeoJsonLayer } from 'deck.gl';\nimport 'mapbox-gl/dist/mapbox-gl.css';\nimport mapboxgl from 'mapbox-gl';\nimport mbxClient from '@mapbox/mapbox-sdk';\nimport mbxDirections from '@mapbox/mapbox-sdk/services/directions';\nimport * as turf from '@turf/helpers'\nimport nearestPointOnLine from '@turf/nearest-point-on-line'\nimport along from '@turf/along'\nconst geoViewport = require('@mapbox/geo-viewport');\n\nconst baseClient = mbxClient({ accessToken: process.env.REACT_APP_MAPBOX_ACCESS_TOKEN });\nconst directionsService = mbxDirections(baseClient);\n\n\nfunction simulateLocation(routeGeometry, routeDistance, cb) {\n  const NUM_SIMULATED_POINTS = 1000;\n  const UPDATE_FREQUENCY_MS = 100; // 0.01Hz\n\n  const distanceIncrement = routeDistance / 1000 / NUM_SIMULATED_POINTS;\n  let step = 0;\n\n  function updateLocation() {\n    step = step + 1;\n    const point = along(routeGeometry, step * distanceIncrement, { units: 'kilometers' });\n\n    cb({\n      coords: {\n        longitude: point.geometry.coordinates[0],\n        latitude: point.geometry.coordinates[1],\n      },\n      timestamp: Date.now()\n    })\n  }\n\n  return setInterval(() => {\n    if (step < NUM_SIMULATED_POINTS) updateLocation();\n  }, UPDATE_FREQUENCY_MS)\n\n}\n\n\nfunction requestDirections(start, end) {\n  const options = {\n    profile: 'driving-traffic',\n    geometries: 'geojson',\n    overview: 'full',\n    steps: true,\n    bannerInstructions: true,\n    waypoints: [{\n      coordinates: start\n    }, {\n      coordinates: end\n    }]\n  };\n\n  return directionsService\n    .getDirections(options)\n    .send()\n    .then((response) => response.body.routes)\n}\n\nfunction requestGeolocation() {\n  return new Promise((resolve, reject) => {\n    navigator.geolocation.getCurrentPosition(resolve, reject);\n  });\n}\n\nfunction watchGeolocation(onSuccess, onError) {\n  return navigator.geolocation.watchPosition(onSuccess, onError, {\n    enableHighAccuracy: true,\n    maximumAge: 5000\n  });\n}\n\nclass App extends Component {\n\n  state = {\n    viewport: {\n      width: window.innerWidth,\n      height: window.innerHeight - 200,\n      latitude: 40.0,\n      longitude: -90.0,\n      zoom: 2,\n      maxZoom: 18,\n      transitionDuration: 1000\n    },\n    geolocationWatcher: null,\n    currentPosition: {\n      latitude: null,\n      longitude: null,\n      lastupdated: null\n    },\n    currentPositionLayer: null,\n    currentRouteStepIndex: 0,\n    searchResult: null,\n    searchResultLayer: null,\n    routeResult: null,\n    routeResultLayer: null,\n    isNavigating: false,\n    simulationIntervalId: null\n  };\n\n  mapRef = React.createRef();\n\n  componentDidMount() {\n    requestGeolocation()\n      .then(p => {\n        this.handlePositionChange(p);\n        this.handleViewportChange({\n          longitude: p.coords.longitude,\n          latitude: p.coords.latitude,\n          zoom: 16\n        });\n      });\n  };\n\n  handleViewportChange = viewport => {\n    this.setState({\n      viewport: { ...this.state.viewport, ...viewport }\n    });\n  };\n\n  handleSearchResult = event => {\n    this.setState({\n      routeResult: null,\n      routeResultLayer: null,\n      searchResult: event.result,\n      searchResultLayer: new GeoJsonLayer({\n        id: 'search-result',\n        data: event.result.geometry,\n        getFillColor: [253, 153, 108, 255],\n        getLineColor: [255, 255, 255, 255],\n        getRadius: 7,\n        pointRadiusMinPixels: 7,\n        getLineWidth: 2,\n        lineWidthMinPixels: 2,\n        stroked: true,\n        filled: true\n      })\n    });\n  };\n\n  handleSearchClear = event => {\n    this.setState({\n      searchResult: null,\n      searchResultLayer: null,\n      routeResult: null,\n      routeResultLayer: null\n    });\n  };\n\n  handlePositionChange = event => {\n    this.setState({\n      currentPosition: {\n        longitude: event.coords.longitude,\n        latitude: event.coords.latitude,\n        lastupdated: event.timestamp\n      },\n      currentPositionLayer: new GeoJsonLayer({\n        id: 'current-position',\n        data: {\n          type: 'Point',\n          coordinates: [event.coords.longitude, event.coords.latitude]\n        },\n        getFillColor: [70, 136, 241, 255],\n        getLineColor: [255, 255, 255, 255],\n        getRadius: 7,\n        pointRadiusMinPixels: 7,\n        getLineWidth: 2,\n        lineWidthMinPixels: 2,\n        stroked: true,\n        filled: true\n      })\n    });\n  };\n\n  handleGetDirections = event => {\n    requestGeolocation()\n      .then(p => this.handlePositionChange(p))\n      .then(() => {\n        const start = [this.state.currentPosition.longitude, this.state.currentPosition.latitude];\n        const end = this.state.searchResult.center;\n        return requestDirections(start, end);\n      })\n      .then(r => this.setState({\n        routeResult: r[0], // TODO show alternatives\n        routeResultLayer: new GeoJsonLayer({\n          id: 'route-result',\n          data: r[0].geometry,\n          lineWidthMinPixels: 3,\n          getLineColor: [66, 100, 251, 200],\n          getLineWidth: 7,\n        })\n      }))\n      .then(() => {\n        const coordinates = this.state.routeResult.geometry.coordinates;\n        const bounds = coordinates.reduce(function(bounds, coord) {\n          return bounds.extend(coord);\n        }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));\n\n        const viewport = geoViewport.viewport(\n          [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()],\n          [400, 400]\n        );\n\n        this.handleViewportChange({\n          longitude: viewport.center[0],\n          latitude: viewport.center[1],\n          zoom: viewport.zoom\n        });\n      })\n      .catch(err => console.error(err));\n  };\n\n  handleNewPositionSuccess = (p) => {\n    let currentRouteStepIndex = this.state.currentRouteStepIndex || 0;\n\n    const currentStep = this.state.routeResult.legs[0].steps[currentRouteStepIndex];\n    const nextStep = this.state.routeResult.legs[0].steps[currentRouteStepIndex+1];\n    const snappedPositionToCurrentStep = nearestPointOnLine(currentStep.geometry, turf.point([p.coords.longitude, p.coords.latitude]));\n    const snappedPositionToNextStep = nearestPointOnLine(nextStep.geometry, turf.point([p.coords.longitude, p.coords.latitude]));\n\n    // decide whether to progress to next step\n    let snappedPosition;\n    // snap to next step is closer than snap to current step,\n    // and snap to next step is less than 50m from the start of the step\n    if (snappedPositionToNextStep.properties.dist < snappedPositionToCurrentStep.properties.dist && snappedPositionToNextStep.properties.location < 0.05) {\n      snappedPosition = snappedPositionToNextStep;\n      currentRouteStepIndex = currentRouteStepIndex + 1;\n    } else {\n      snappedPosition = snappedPositionToCurrentStep;\n    }\n\n    const distanceAlongGeometry = snappedPosition.properties.location * 1000;\n\n    this.handlePositionChange(p);\n    this.handleViewportChange({\n      longitude: p.coords.longitude,\n      latitude: p.coords.latitude,\n      zoom: 16\n    });\n\n    this.setState({\n      currentRouteStepIndex: currentRouteStepIndex,\n      distanceAlongGeometry: distanceAlongGeometry,\n    });\n  };\n\n  handleNewPositionError = (err) => {\n    console.error(err);\n  };\n\n  handleStartNavigation = () => {\n    const geolocationWatcher = watchGeolocation(this.handleNewPositionSuccess, this.handleNewPositionError);\n    this.setState({\n      isNavigating: true,\n      geolocationWatcher\n    });\n  };\n\n  handleStartSimulation = () => {\n    const { geometry, distance } = this.state.routeResult;\n    const simulationIntervalId = simulateLocation(geometry, distance, this.handleNewPositionSuccess);\n    this.setState({\n      isNavigating: true,\n      simulationIntervalId\n    });\n  };\n\n  handleCancelNavigation = () => {\n    clearInterval(this.state.simulationIntervalId);\n    this.setState({\n      isNavigating: false,\n      simulationIntervalId: null\n    });\n  };\n\n  render() {\n    const { viewport, searchResult, searchResultLayer, routeResult, routeResultLayer, currentPosition, currentPositionLayer, currentRouteStepIndex, distanceAlongGeometry, isNavigating } = this.state;\n\n    let BottomBanner;\n    if (searchResult && !routeResult) {\n      BottomBanner = <SearchDetails searchResult={searchResult} onClick={this.handleGetDirections} />\n    } else if (routeResult) {\n      BottomBanner = <RouteDetails routeResult={routeResult} isNavigating={isNavigating} onClickStartNavigation={this.handleStartNavigation} onClickStartSimulation={this.handleStartSimulation} onClickCancelNavigation={this.handleCancelNavigation} />\n    }\n\n    return (\n      <>\n        { isNavigating && routeResult &&\n          <Banner routeResult={routeResult} distanceAlongGeometry={distanceAlongGeometry} currentRouteStepIndex={currentRouteStepIndex} />\n        }\n        <MapGL\n          mapStyle='mapbox://styles/mapbox/navigation-guidance-day-v4'\n          ref={this.mapRef}\n          {...viewport}\n          onViewportChange={this.handleViewportChange}\n        >\n          { !isNavigating &&\n            <Geocoder\n              mapRef={this.mapRef}\n              onViewportChange={this.handleViewportChange}\n              onResult={this.handleSearchResult}\n              onClear={this.handleSearchClear}\n              mapboxApiAccessToken={process.env.REACT_APP_MAPBOX_ACCESS_TOKEN}\n              proximity={currentPosition}\n              position='top-left'\n              placeholder='Where to?...'\n            />\n          }\n          <DeckGL {...viewport} layers={[searchResultLayer, routeResultLayer, currentPositionLayer]} />\n        </MapGL>\n        {BottomBanner}\n      </>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}