{"version":3,"sources":["Banner.js","RouteDetails.js","SearchDetails.js","App.js","serviceWorker.js","index.js"],"names":["Banner","_this$props","this","props","routeResult","distanceAlongGeometry","currentRouteStepIndex","currentStep","legs","steps","distanceToManeuver","distance","bannerInstruction","bannerInstructions","i","length","react_default","a","createElement","className","primary","text","secondary","Component","RouteDetails","sec","m","onClickStartNavigation","onClickStartSimulation","onClickCancelNavigation","isNavigating","time","duration","value","Math","round","unit","onClick","searchResult","properties","address","geoViewport","require","baseClient","mbxClient","accessToken","process","directionsService","mbxDirections","simulateLocation","routeGeometry","routeDistance","cb","distanceIncrement","step","setInterval","point","along","units","coords","longitude","geometry","coordinates","latitude","timestamp","Date","now","updateLocation","App","state","viewport","width","window","innerWidth","height","innerHeight","zoom","maxZoom","transitionDuration","geolocationWatcher","currentPosition","currentPositionLayer","GeoJsonLayer","id","data","type","getFillColor","getRadius","pointRadiusMinPixels","searchResultLayer","routeResultLayer","simulationIntervalId","mapRef","React","createRef","handleViewportChange","_this","setState","Object","objectSpread","handleSearchResult","event","result","handleSearchClear","handleGetDirections","Promise","resolve","reject","then","p","lastupdated","start","end","options","profile","geometries","overview","waypoints","getDirections","send","response","body","routes","requestDirections","center","r","lineWidthMinPixels","getLineColor","getLineWidth","bounds","reduce","coord","extend","mapboxgl","LngLatBounds","getWest","getSouth","getEast","getNorth","catch","err","console","error","handleNewPositionSuccess","snappedPosition","nextStep","snappedPositionToCurrentStep","nearestPointOnLine","turf","snappedPositionToNextStep","dist","location","handleNewPositionError","handleStartNavigation","onSuccess","onError","navigator","geolocation","watchPosition","enableHighAccuracy","maximumAge","handleStartSimulation","_this$state$routeResu","handleCancelNavigation","clearInterval","BottomBanner","_this$state","SearchDetails","src_RouteDetails","Fragment","src_Banner","esm","assign","mapStyle","ref","onViewportChange","dist_default","onResult","onClear","mapboxApiAccessToken","proximity","position","placeholder","dist_esm","layers","Boolean","hostname","match","ReactDOM","render","src_App","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.cde9571e.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './banner.css';\n\nclass Banner extends Component {\n  render() {\n    const { routeResult, distanceAlongGeometry, currentRouteStepIndex } = this.props;\n    const currentStep = routeResult.legs[0].steps[currentRouteStepIndex]; // TODO how to progress to next step\n\n    let distanceToManeuver = currentStep.distance - distanceAlongGeometry;\n\n    let bannerInstruction = currentStep.bannerInstructions[0];\n    for (let i = 0; i < currentStep.bannerInstructions.length; i++) {\n      if (currentStep.bannerInstructions[i].distanceAlongGeometry > distanceToManeuver) {\n        bannerInstruction = currentStep.bannerInstructions[i];\n      }\n    }\n\n    return (\n      <div className='banner'>\n        <div className='primary'>\n          {bannerInstruction.primary.text}\n        </div>\n        <div className='secondary'>\n          {bannerInstruction.secondary && bannerInstruction.secondary.text}\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default Banner;\n","import React, { Component } from 'react';\n\nfunction formatTime(sec) {\n  const value = Math.round(sec / 60);\n  const unit = 'min';\n\n  return { value, unit }\n}\n\n\nfunction formatDistance(m) {\n  const value = Math.round(m / 1000);\n  const unit = 'km';\n\n  return { value, unit }\n}\n\nclass RouteDetails extends Component {\n  render() {\n    const { routeResult, onClickStartNavigation, onClickStartSimulation, onClickCancelNavigation, isNavigating } = this.props;\n\n    const time = formatTime(routeResult.duration);\n    const distance = formatDistance(routeResult.distance);\n\n    return (\n      <div>\n        { isNavigating ? (\n          <button onClick={onClickCancelNavigation}>Cancel</button>\n        ) : (\n          <div>\n            <div>\n              {time.value} {time.unit} ({distance.value} {distance.unit})\n            </div>\n            <div>\n              <button onClick={onClickStartNavigation}>Start</button>\n              <button onClick={onClickStartSimulation}>Simulate</button>\n            </div>\n          </div>\n        )}\n      </div>\n    )\n  }\n}\n\nexport default RouteDetails;\n","import React, { Component } from 'react';\n\nclass RouteDetails extends Component {\n  render() {\n    const { searchResult, onClick } = this.props;\n    return (\n      <div>\n        <div>{searchResult.text}</div>\n        <div>{searchResult.properties.address}</div>\n        <button onClick={onClick}>Directions</button>\n      </div>\n    )\n  }\n}\n\nexport default RouteDetails;\n","import React, { Component } from 'react';\nimport Banner from './Banner';\nimport RouteDetails from './RouteDetails';\nimport SearchDetails from './SearchDetails';\nimport MapGL from 'react-map-gl';\nimport Geocoder from 'react-map-gl-geocoder';\nimport DeckGL, { GeoJsonLayer } from 'deck.gl';\nimport 'mapbox-gl/dist/mapbox-gl.css';\nimport mapboxgl from 'mapbox-gl';\nimport mbxClient from '@mapbox/mapbox-sdk';\nimport mbxDirections from '@mapbox/mapbox-sdk/services/directions';\nimport * as turf from '@turf/helpers'\nimport nearestPointOnLine from '@turf/nearest-point-on-line'\nimport along from '@turf/along'\nconst geoViewport = require('@mapbox/geo-viewport');\n\nconst baseClient = mbxClient({ accessToken: process.env.REACT_APP_MAPBOX_ACCESS_TOKEN });\nconst directionsService = mbxDirections(baseClient);\n\n\nfunction simulateLocation(routeGeometry, routeDistance, cb) {\n  const NUM_SIMULATED_POINTS = 1000;\n  const UPDATE_FREQUENCY_MS = 100; // 0.01Hz\n\n  const distanceIncrement = routeDistance / 1000 / NUM_SIMULATED_POINTS;\n  let step = 0;\n\n  function updateLocation() {\n    step = step + 1;\n    const point = along(routeGeometry, step * distanceIncrement, { units: 'kilometers' });\n\n    cb({\n      coords: {\n        longitude: point.geometry.coordinates[0],\n        latitude: point.geometry.coordinates[1],\n      },\n      timestamp: Date.now()\n    })\n  }\n\n  return setInterval(() => {\n    if (step < NUM_SIMULATED_POINTS) updateLocation();\n  }, UPDATE_FREQUENCY_MS)\n\n}\n\n\nfunction requestDirections(start, end) {\n  const options = {\n    profile: 'driving-traffic',\n    geometries: 'geojson',\n    overview: 'full',\n    steps: true,\n    bannerInstructions: true,\n    waypoints: [{\n      coordinates: start\n    }, {\n      coordinates: end\n    }]\n  };\n\n  return directionsService\n    .getDirections(options)\n    .send()\n    .then((response) => response.body.routes)\n}\n\nfunction requestGeolocation() {\n  return new Promise((resolve, reject) => {\n    resolve({\n      coords: {\n        latitude: 38.8980586,\n        longitude: -77.1876467\n      }\n    });\n    // navigator.geolocation.getCurrentPosition(resolve, reject);\n  });\n}\n\nfunction watchGeolocation(onSuccess, onError) {\n  return navigator.geolocation.watchPosition(onSuccess, onError, {\n    enableHighAccuracy: true,\n    maximumAge: 5000\n  });\n}\n\nclass App extends Component {\n\n  state = {\n    viewport: {\n      width: window.innerWidth,\n      height: window.innerHeight - 100,\n      latitude: 38.8980586,\n      longitude: -77.1876467,\n      zoom: 16,\n      maxZoom: 18,\n      transitionDuration: 1000\n    },\n    geolocationWatcher: null,\n    currentPosition: {\n      latitude: 38.8980586,\n      longitude: -77.1876467\n    },\n    currentPositionLayer: new GeoJsonLayer({\n      id: 'current-position',\n      data: {\n        type: 'Point',\n        coordinates: [-77.1876467, 38.8980586]\n      },\n      getFillColor: [255, 255, 255, 255],\n      getRadius: 5,\n      pointRadiusMinPixels: 5\n    }),\n    currentRouteStepIndex: 0,\n    searchResult: null,\n    searchResultLayer: null,\n    routeResult: null,\n    routeResultLayer: null,\n    isNavigating: false,\n    simulationIntervalId: null\n  };\n\n  mapRef = React.createRef();\n\n  handleViewportChange = viewport => {\n    this.setState({\n      viewport: { ...this.state.viewport, ...viewport }\n    });\n  };\n\n  handleSearchResult = event => {\n    this.setState({\n      routeResult: null,\n      routeResultLayer: null,\n      searchResult: event.result,\n      searchResultLayer: new GeoJsonLayer({\n        id: 'search-result',\n        data: event.result.geometry,\n        getFillColor: [160, 160, 180, 200],\n        getRadius: 5,\n        pointRadiusMinPixels: 5\n      })\n    });\n  };\n\n  handleSearchClear = event => {\n    this.setState({\n      searchResult: null,\n      searchResultLayer: null,\n      routeResult: null,\n      routeResultLayer: null\n    });\n  };\n\n  handleGetDirections = event => {\n    requestGeolocation()\n      .then(p => this.setState({\n        currentPosition: {\n          longitude: p.coords.longitude,\n          latitude: p.coords.latitude,\n          lastupdated: p.timestamp\n        },\n        currentPositionLayer: new GeoJsonLayer({\n          id: 'current-position',\n          data: {\n            type: 'Point',\n            coordinates: [p.coords.longitude, p.coords.latitude]\n          },\n          getFillColor: [255, 255, 255, 255],\n          getRadius: 5,\n          pointRadiusMinPixels: 5\n        })\n      }))\n      .then(() => {\n        const start = [this.state.currentPosition.longitude, this.state.currentPosition.latitude];\n        const end = this.state.searchResult.center;\n        return requestDirections(start, end);\n      })\n      .then(r => this.setState({\n        routeResult: r[0], // TODO show alternatives\n        routeResultLayer: new GeoJsonLayer({\n          id: 'route-result',\n          data: r[0].geometry,\n          lineWidthMinPixels: 3,\n          getLineColor: [66, 100, 251, 255],\n          getLineWidth: 5,\n        })\n      }))\n      .then(() => {\n        const coordinates = this.state.routeResult.geometry.coordinates;\n        const bounds = coordinates.reduce(function(bounds, coord) {\n          return bounds.extend(coord);\n        }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));\n\n        const viewport = geoViewport.viewport(\n          [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()],\n          [400, 400]\n        );\n\n        this.handleViewportChange({\n          longitude: viewport.center[0],\n          latitude: viewport.center[1],\n          zoom: viewport.zoom\n        });\n      })\n      .catch(err => console.error(err));\n  };\n\n  handleNewPositionSuccess = (p) => {\n    let currentRouteStepIndex = this.state.currentRouteStepIndex || 0;\n\n    const currentStep = this.state.routeResult.legs[0].steps[currentRouteStepIndex];\n    const nextStep = this.state.routeResult.legs[0].steps[currentRouteStepIndex+1];\n    const snappedPositionToCurrentStep = nearestPointOnLine(currentStep.geometry, turf.point([p.coords.longitude, p.coords.latitude]));\n    const snappedPositionToNextStep = nearestPointOnLine(nextStep.geometry, turf.point([p.coords.longitude, p.coords.latitude]));\n\n    // decide whether to progress to next step\n    let snappedPosition;\n    // snap to next step is closer than snap to current step,\n    // and snap to next step is less than 50m from the start of the step\n    if (snappedPositionToNextStep.properties.dist < snappedPositionToCurrentStep.properties.dist && snappedPositionToNextStep.properties.location < 0.05) {\n      snappedPosition = snappedPositionToNextStep;\n      currentRouteStepIndex = currentRouteStepIndex + 1;\n    } else {\n      snappedPosition = snappedPositionToCurrentStep;\n    }\n\n    const distanceAlongGeometry = snappedPosition.properties.location * 1000;\n\n    this.setState({\n      viewport: {\n        ...this.state.viewport,\n        longitude: p.coords.longitude,\n        latitude: p.coords.latitude,\n        zoom: 16\n      },\n      currentPosition: {\n        longitude: p.coords.longitude,\n        latitude: p.coords.latitude,\n        lastupdated: p.timestamp\n      },\n      currentRouteStepIndex: currentRouteStepIndex,\n      distanceAlongGeometry: distanceAlongGeometry,\n      currentPositionLayer: new GeoJsonLayer({\n        id: 'current-position',\n        data: {\n          type: 'Point',\n          coordinates: [p.coords.longitude, p.coords.latitude]\n        },\n        getFillColor: [255, 255, 255, 255],\n        getRadius: 5,\n        pointRadiusMinPixels: 5\n      })\n    });\n  };\n\n  handleNewPositionError = (err) => {\n    console.error(err);\n  };\n\n  handleStartNavigation = () => {\n    const geolocationWatcher = watchGeolocation(this.handleNewPositionSuccess, this.handleNewPositionError);\n    this.setState({\n      isNavigating: true,\n      geolocationWatcher\n    });\n  };\n\n  handleStartSimulation = () => {\n    const { geometry, distance } = this.state.routeResult;\n    const simulationIntervalId = simulateLocation(geometry, distance, this.handleNewPositionSuccess);\n    this.setState({\n      isNavigating: true,\n      simulationIntervalId\n    });\n  };\n\n  handleCancelNavigation = () => {\n    clearInterval(this.state.simulationIntervalId);\n    this.setState({\n      isNavigating: false,\n      simulationIntervalId: null\n    });\n  };\n\n  render() {\n    const { viewport, searchResult, searchResultLayer, routeResult, routeResultLayer, currentPosition, currentPositionLayer, currentRouteStepIndex, distanceAlongGeometry, isNavigating } = this.state;\n\n    let BottomBanner;\n    if (searchResult && !routeResult) {\n      BottomBanner = <SearchDetails searchResult={searchResult} onClick={this.handleGetDirections} />\n    } else if (routeResult) {\n      BottomBanner = <RouteDetails routeResult={routeResult} isNavigating={isNavigating} onClickStartNavigation={this.handleStartNavigation} onClickStartSimulation={this.handleStartSimulation} onClickCancelNavigation={this.handleCancelNavigation} />\n    }\n\n    return (\n      <>\n        { isNavigating && routeResult &&\n          <Banner routeResult={routeResult} distanceAlongGeometry={distanceAlongGeometry} currentRouteStepIndex={currentRouteStepIndex} />\n        }\n        <MapGL\n          mapStyle='mapbox://styles/mapbox/navigation-guidance-day-v4'\n          ref={this.mapRef}\n          {...viewport}\n          onViewportChange={this.handleViewportChange}\n        >\n          { !isNavigating &&\n            <Geocoder\n              mapRef={this.mapRef}\n              onViewportChange={this.handleViewportChange}\n              onResult={this.handleSearchResult}\n              onClear={this.handleSearchClear}\n              mapboxApiAccessToken={process.env.REACT_APP_MAPBOX_ACCESS_TOKEN}\n              proximity={currentPosition}\n              position='top-left'\n              placeholder='Where to?...'\n            />\n          }\n          <DeckGL {...viewport} layers={[searchResultLayer, routeResultLayer, currentPositionLayer]} />\n        </MapGL>\n        {BottomBanner}\n      </>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}