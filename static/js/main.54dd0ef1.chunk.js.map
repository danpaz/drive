{"version":3,"sources":["Banner.js","RouteDetails.js","SearchDetails.js","App.js","serviceWorker.js","index.js"],"names":["Banner","_this$props","this","props","routeResult","distanceAlongGeometry","currentRouteStepIndex","currentStep","legs","steps","distanceToManeuver","distance","bannerInstruction","bannerInstructions","i","length","react_default","a","createElement","className","primary","text","secondary","Component","RouteDetails","sec","m","onClickStartNavigation","onClickStartSimulation","onClickCancelNavigation","isNavigating","time","duration","value","Math","round","unit","onClick","searchResult","properties","address","geoViewport","require","baseClient","mbxClient","accessToken","process","directionsService","mbxDirections","simulateLocation","routeGeometry","routeDistance","cb","distanceIncrement","step","setInterval","point","along","units","coords","longitude","geometry","coordinates","latitude","timestamp","Date","now","updateLocation","App","state","viewport","width","height","zoom","maxZoom","transitionDuration","geolocationWatcher","currentPosition","currentPositionLayer","GeoJsonLayer","id","data","type","getFillColor","getRadius","pointRadiusMinPixels","searchResultLayer","routeResultLayer","simulationIntervalId","mapRef","React","createRef","resize","_this","handleViewportChange","window","innerWidth","innerHeight","setState","Object","objectSpread","handleSearchResult","event","result","handleSearchClear","handleGetDirections","Promise","resolve","reject","then","p","lastupdated","start","end","options","profile","geometries","overview","waypoints","getDirections","send","response","body","routes","requestDirections","center","r","lineWidthMinPixels","getLineColor","getLineWidth","bounds","reduce","coord","extend","mapboxgl","LngLatBounds","getWest","getSouth","getEast","getNorth","catch","err","console","error","handleNewPositionSuccess","snappedPosition","nextStep","snappedPositionToCurrentStep","nearestPointOnLine","turf","snappedPositionToNextStep","dist","location","handleNewPositionError","handleStartNavigation","onSuccess","onError","navigator","geolocation","watchPosition","enableHighAccuracy","maximumAge","handleStartSimulation","_this$state$routeResu","handleCancelNavigation","clearInterval","addEventListener","removeEventListener","BottomBanner","_this$state","SearchDetails","src_RouteDetails","Fragment","src_Banner","esm","assign","mapStyle","ref","onViewportChange","dist_default","onResult","onClear","mapboxApiAccessToken","proximity","position","placeholder","dist_esm","layers","Boolean","hostname","match","ReactDOM","render","src_App","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.54dd0ef1.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './banner.css';\n\nclass Banner extends Component {\n  render() {\n    const { routeResult, distanceAlongGeometry, currentRouteStepIndex } = this.props;\n    const currentStep = routeResult.legs[0].steps[currentRouteStepIndex]; // TODO how to progress to next step\n\n    let distanceToManeuver = currentStep.distance - distanceAlongGeometry;\n\n    let bannerInstruction = currentStep.bannerInstructions[0];\n    for (let i = 0; i < currentStep.bannerInstructions.length; i++) {\n      if (currentStep.bannerInstructions[i].distanceAlongGeometry > distanceToManeuver) {\n        bannerInstruction = currentStep.bannerInstructions[i];\n      }\n    }\n\n    return (\n      <div className='banner'>\n        <div className='primary'>\n          {bannerInstruction.primary.text}\n        </div>\n        <div className='secondary'>\n          {bannerInstruction.secondary && bannerInstruction.secondary.text}\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default Banner;\n","import React, { Component } from 'react';\n\nfunction formatTime(sec) {\n  const value = Math.round(sec / 60);\n  const unit = 'min';\n\n  return { value, unit }\n}\n\n\nfunction formatDistance(m) {\n  const value = Math.round(m / 1000);\n  const unit = 'km';\n\n  return { value, unit }\n}\n\nclass RouteDetails extends Component {\n  render() {\n    const { routeResult, onClickStartNavigation, onClickStartSimulation, onClickCancelNavigation, isNavigating } = this.props;\n\n    const time = formatTime(routeResult.duration);\n    const distance = formatDistance(routeResult.distance);\n\n    return (\n      <div>\n        { isNavigating ? (\n          <button onClick={onClickCancelNavigation}>Cancel</button>\n        ) : (\n          <div>\n            <div>\n              {time.value} {time.unit} ({distance.value} {distance.unit})\n            </div>\n            <div>\n              <button onClick={onClickStartNavigation}>Start</button>\n              <button onClick={onClickStartSimulation}>Simulate</button>\n            </div>\n          </div>\n        )}\n      </div>\n    )\n  }\n}\n\nexport default RouteDetails;\n","import React, { Component } from 'react';\n\nclass RouteDetails extends Component {\n  render() {\n    const { searchResult, onClick } = this.props;\n    return (\n      <div>\n        <div>{searchResult.text}</div>\n        <div>{searchResult.properties.address}</div>\n        <button onClick={onClick}>Directions</button>\n      </div>\n    )\n  }\n}\n\nexport default RouteDetails;\n","import React, { Component } from 'react';\nimport Banner from './Banner';\nimport RouteDetails from './RouteDetails';\nimport SearchDetails from './SearchDetails';\nimport MapGL from 'react-map-gl';\nimport Geocoder from 'react-map-gl-geocoder';\nimport DeckGL, { GeoJsonLayer } from 'deck.gl';\nimport 'mapbox-gl/dist/mapbox-gl.css';\nimport mapboxgl from 'mapbox-gl';\nimport mbxClient from '@mapbox/mapbox-sdk';\nimport mbxDirections from '@mapbox/mapbox-sdk/services/directions';\nimport * as turf from '@turf/helpers'\nimport nearestPointOnLine from '@turf/nearest-point-on-line'\nimport along from '@turf/along'\nconst geoViewport = require('@mapbox/geo-viewport');\n\nconst baseClient = mbxClient({ accessToken: process.env.REACT_APP_MAPBOX_ACCESS_TOKEN });\nconst directionsService = mbxDirections(baseClient);\n\n\nfunction simulateLocation(routeGeometry, routeDistance, cb) {\n  const NUM_SIMULATED_POINTS = 1000;\n  const UPDATE_FREQUENCY_MS = 100; // 0.01Hz\n\n  const distanceIncrement = routeDistance / 1000 / NUM_SIMULATED_POINTS;\n  let step = 0;\n\n  function updateLocation() {\n    step = step + 1;\n    const point = along(routeGeometry, step * distanceIncrement, { units: 'kilometers' });\n\n    cb({\n      coords: {\n        longitude: point.geometry.coordinates[0],\n        latitude: point.geometry.coordinates[1],\n      },\n      timestamp: Date.now()\n    })\n  }\n\n  return setInterval(() => {\n    if (step < NUM_SIMULATED_POINTS) updateLocation();\n  }, UPDATE_FREQUENCY_MS)\n\n}\n\n\nfunction requestDirections(start, end) {\n  const options = {\n    profile: 'driving-traffic',\n    geometries: 'geojson',\n    overview: 'full',\n    steps: true,\n    bannerInstructions: true,\n    waypoints: [{\n      coordinates: start\n    }, {\n      coordinates: end\n    }]\n  };\n\n  return directionsService\n    .getDirections(options)\n    .send()\n    .then((response) => response.body.routes)\n}\n\nfunction requestGeolocation() {\n  return new Promise((resolve, reject) => {\n    resolve({\n      coords: {\n        latitude: 38.8980586,\n        longitude: -77.1876467\n      }\n    });\n    // navigator.geolocation.getCurrentPosition(resolve, reject);\n  });\n}\n\nfunction watchGeolocation(onSuccess, onError) {\n  return navigator.geolocation.watchPosition(onSuccess, onError, {\n    enableHighAccuracy: true,\n    maximumAge: 5000\n  });\n}\n\nclass App extends Component {\n\n  state = {\n    viewport: {\n      width: 400,\n      height: 600,\n      latitude: 38.8980586,\n      longitude: -77.1876467,\n      zoom: 16,\n      maxZoom: 18,\n      transitionDuration: 1000\n    },\n    geolocationWatcher: null,\n    currentPosition: {\n      latitude: 38.8980586,\n      longitude: -77.1876467\n    },\n    currentPositionLayer: new GeoJsonLayer({\n      id: 'current-position',\n      data: {\n        type: 'Point',\n        coordinates: [-77.1876467, 38.8980586]\n      },\n      getFillColor: [255, 255, 255, 255],\n      getRadius: 5,\n      pointRadiusMinPixels: 5\n    }),\n    currentRouteStepIndex: 0,\n    searchResult: null,\n    searchResultLayer: null,\n    routeResult: null,\n    routeResultLayer: null,\n    isNavigating: false,\n    simulationIntervalId: null\n  };\n\n  mapRef = React.createRef();\n\n  componentDidMount() {\n    window.addEventListener('resize', this.resize);\n    this.resize();\n  };\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.resize);\n  };\n\n  resize = () => {\n    this.handleViewportChange({\n      width: window.innerWidth,\n      height: window.innerHeight - 100\n    });\n  };\n\n  handleViewportChange = viewport => {\n    this.setState({\n      viewport: { ...this.state.viewport, ...viewport }\n    });\n  };\n\n  handleSearchResult = event => {\n    this.setState({\n      routeResult: null,\n      routeResultLayer: null,\n      searchResult: event.result,\n      searchResultLayer: new GeoJsonLayer({\n        id: 'search-result',\n        data: event.result.geometry,\n        getFillColor: [160, 160, 180, 200],\n        getRadius: 5,\n        pointRadiusMinPixels: 5\n      })\n    });\n  };\n\n  handleSearchClear = event => {\n    this.setState({\n      searchResult: null,\n      searchResultLayer: null,\n      routeResult: null,\n      routeResultLayer: null\n    });\n  };\n\n  handleGetDirections = event => {\n    requestGeolocation()\n      .then(p => this.setState({\n        currentPosition: {\n          longitude: p.coords.longitude,\n          latitude: p.coords.latitude,\n          lastupdated: p.timestamp\n        },\n        currentPositionLayer: new GeoJsonLayer({\n          id: 'current-position',\n          data: {\n            type: 'Point',\n            coordinates: [p.coords.longitude, p.coords.latitude]\n          },\n          getFillColor: [255, 255, 255, 255],\n          getRadius: 5,\n          pointRadiusMinPixels: 5\n        })\n      }))\n      .then(() => {\n        const start = [this.state.currentPosition.longitude, this.state.currentPosition.latitude];\n        const end = this.state.searchResult.center;\n        return requestDirections(start, end);\n      })\n      .then(r => this.setState({\n        routeResult: r[0], // TODO show alternatives\n        routeResultLayer: new GeoJsonLayer({\n          id: 'route-result',\n          data: r[0].geometry,\n          lineWidthMinPixels: 3,\n          getLineColor: [66, 100, 251, 255],\n          getLineWidth: 5,\n        })\n      }))\n      .then(() => {\n        const coordinates = this.state.routeResult.geometry.coordinates;\n        const bounds = coordinates.reduce(function(bounds, coord) {\n          return bounds.extend(coord);\n        }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));\n\n        const viewport = geoViewport.viewport(\n          [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()],\n          [400, 400]\n        );\n\n        this.handleViewportChange({\n          longitude: viewport.center[0],\n          latitude: viewport.center[1],\n          zoom: viewport.zoom\n        });\n      })\n      .catch(err => console.error(err));\n  };\n\n  handleNewPositionSuccess = (p) => {\n    let currentRouteStepIndex = this.state.currentRouteStepIndex || 0;\n\n    const currentStep = this.state.routeResult.legs[0].steps[currentRouteStepIndex];\n    const nextStep = this.state.routeResult.legs[0].steps[currentRouteStepIndex+1];\n    const snappedPositionToCurrentStep = nearestPointOnLine(currentStep.geometry, turf.point([p.coords.longitude, p.coords.latitude]));\n    const snappedPositionToNextStep = nearestPointOnLine(nextStep.geometry, turf.point([p.coords.longitude, p.coords.latitude]));\n\n    // decide whether to progress to next step\n    let snappedPosition;\n    // snap to next step is closer than snap to current step,\n    // and snap to next step is less than 50m from the start of the step\n    if (snappedPositionToNextStep.properties.dist < snappedPositionToCurrentStep.properties.dist && snappedPositionToNextStep.properties.location < 0.05) {\n      snappedPosition = snappedPositionToNextStep;\n      currentRouteStepIndex = currentRouteStepIndex + 1;\n    } else {\n      snappedPosition = snappedPositionToCurrentStep;\n    }\n\n    const distanceAlongGeometry = snappedPosition.properties.location * 1000;\n\n    this.setState({\n      viewport: {\n        ...this.state.viewport,\n        longitude: p.coords.longitude,\n        latitude: p.coords.latitude,\n        zoom: 16\n      },\n      currentPosition: {\n        longitude: p.coords.longitude,\n        latitude: p.coords.latitude,\n        lastupdated: p.timestamp\n      },\n      currentRouteStepIndex: currentRouteStepIndex,\n      distanceAlongGeometry: distanceAlongGeometry,\n      currentPositionLayer: new GeoJsonLayer({\n        id: 'current-position',\n        data: {\n          type: 'Point',\n          coordinates: [p.coords.longitude, p.coords.latitude]\n        },\n        getFillColor: [255, 255, 255, 255],\n        getRadius: 5,\n        pointRadiusMinPixels: 5\n      })\n    });\n  };\n\n  handleNewPositionError = (err) => {\n    console.error(err);\n  };\n\n  handleStartNavigation = () => {\n    const geolocationWatcher = watchGeolocation(this.handleNewPositionSuccess, this.handleNewPositionError);\n    this.setState({\n      isNavigating: true,\n      geolocationWatcher\n    });\n  };\n\n  handleStartSimulation = () => {\n    const { geometry, distance } = this.state.routeResult;\n    const simulationIntervalId = simulateLocation(geometry, distance, this.handleNewPositionSuccess);\n    this.setState({\n      isNavigating: true,\n      simulationIntervalId\n    });\n  };\n\n  handleCancelNavigation = () => {\n    clearInterval(this.state.simulationIntervalId);\n    this.setState({\n      isNavigating: false,\n      simulationIntervalId: null\n    });\n  };\n\n  render() {\n    const { viewport, searchResult, searchResultLayer, routeResult, routeResultLayer, currentPosition, currentPositionLayer, currentRouteStepIndex, distanceAlongGeometry, isNavigating } = this.state;\n\n    let BottomBanner;\n    if (searchResult && !routeResult) {\n      BottomBanner = <SearchDetails searchResult={searchResult} onClick={this.handleGetDirections} />\n    } else if (routeResult) {\n      BottomBanner = <RouteDetails routeResult={routeResult} isNavigating={isNavigating} onClickStartNavigation={this.handleStartNavigation} onClickStartSimulation={this.handleStartSimulation} onClickCancelNavigation={this.handleCancelNavigation} />\n    }\n\n    return (\n      <>\n        { isNavigating && routeResult &&\n          <Banner routeResult={routeResult} distanceAlongGeometry={distanceAlongGeometry} currentRouteStepIndex={currentRouteStepIndex} />\n        }\n        <MapGL\n          mapStyle='mapbox://styles/mapbox/navigation-guidance-day-v4'\n          ref={this.mapRef}\n          {...viewport}\n          onViewportChange={this.handleViewportChange}\n        >\n          { !isNavigating &&\n            <Geocoder\n              mapRef={this.mapRef}\n              onViewportChange={this.handleViewportChange}\n              onResult={this.handleSearchResult}\n              onClear={this.handleSearchClear}\n              mapboxApiAccessToken={process.env.REACT_APP_MAPBOX_ACCESS_TOKEN}\n              proximity={currentPosition}\n              position='top-left'\n              placeholder='Where to?...'\n            />\n          }\n          <DeckGL {...viewport} layers={[searchResultLayer, routeResultLayer, currentPositionLayer]} />\n        </MapGL>\n        {BottomBanner}\n      </>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}